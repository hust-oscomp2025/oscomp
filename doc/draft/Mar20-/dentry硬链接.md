# dentry 硬链接关系管理详解

## 为什么在 dentry 中需要维护硬链接表？

dentry 中的 `d_alias` 字段是跟踪硬链接关系的关键部分，它有几个重要作用：

1. **快速定位**：当 inode 发生变化时（如修改时间、权限变更），需要快速找到所有对应的 dentry 以更新/无效化缓存

2. **一致性保障**：确保一个 inode 的所有视图（不同路径名）保持同步

3. **操作传播**：一个 dentry 上的操作（如文件删除）可能需要影响其他共享同一 inode 的 dentry

4. **高效遍历**：无需扫描整个 dentry 缓存就能找到所有指向特定 inode 的 dentry

## 硬链接表的表头在哪里？

**表头在 inode 结构中**，而不在 dentry 中：

```c
struct inode {
    // ...其他字段
    struct list_head i_dentry;    // 所有指向此inode的dentry列表的表头
    // ...其他字段
};
```

dentry 中的 `d_alias` 是这个列表的节点，而不是表头：

```c
// 通过 d_alias 将 dentry 链接到 inode 的 i_dentry 列表中
list_add(&dentry->d_alias, &inode->i_dentry);
```

## 硬链接信息如何写回磁盘？

这是一个重要的区分点：**硬链接关系列表不直接写回磁盘**。

### 磁盘上的硬链接存储：

1. **链接计数**：磁盘上的 inode 只存储一个数值字段 `nlinks`，表示有多少目录项指向此 inode

2. **目录项**：每个硬链接在各自的目录中存储为独立的目录项，包含：
   - 文件名
   - 指向同一 inode 的 inode 号

3. **无明确关联**：磁盘上没有明确存储"哪些文件名指向同一 inode"的表格

### 内存与磁盘的转换：

1. **加载时**：
   - 当一个 inode 被加载进内存
   - 随后不同路径中的目录项被访问时
   - 它们会通过 `d_alias` 链到同一个 inode 的 `i_dentry` 列表上

2. **写回时**：
   - 只有 inode 的链接计数 (`i_nlink`) 被写回磁盘
   - 各目录项各自写回各自所在的目录块

这种设计将运行时需要的详细关联关系（内存中的链表）与存储需要的最小信息（磁盘上的计数）分离，既高效又节省空间。