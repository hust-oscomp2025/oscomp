确实，`kiocb`和`file`结构体中都有位置指针（loff_t类型的字段）。这不完全是重复，而是反映了它们不同的用途和生命周期。

### `struct file`中的位置指针 (`f_pos`)
`file->f_pos`是文件在进程上下文中的"官方"位置，表示文件描述符当前的读写位置。这个位置:

1. **持久性**：在整个文件打开期间持续存在
2. **共享性**：如果多个进程共享同一个文件表项（通过`fork()`或`dup()`），它们也共享这个位置
3. **系统调用默认位置**：标准系统调用如`read()`和`write()`默认使用这个位置
4. **状态跟踪**：跟踪应用程序对文件的访问状态

### `struct kiocb`中的位置指针 (`ki_pos`)
`kiocb->ki_pos`是针对单个I/O操作的位置，用于以下场景：

1. **位置独立性**：允许单个I/O操作在不影响文件"官方"位置的情况下进行（如`pread()`和`pwrite()`）
2. **操作原子性**：提供I/O操作的原子性保证，使得操作期间位置不会被其他线程修改
3. **并发I/O**：允许从同一个文件的不同位置进行并发读写
4. **I/O栈封装**：封装I/O操作的所有上下文，便于通过I/O栈传递

### 两者之间的关系

1. 初始化`kiocb`时，通常从`file->f_pos`复制位置到`kiocb->ki_pos`
2. I/O操作完成后，除非设置了`KIOCB_NOUPDATE_POS`标志，否则`kiocb->ki_pos`会更新回`file->f_pos`
3. 对于pread/pwrite等不更新文件位置的操作，只更新`kiocb->ki_pos`而不更新`file->f_pos`

这种设计允许更灵活的I/O操作，同时维护了应用程序对文件位置的预期。它还为将来实现异步I/O奠定了基础，因为每个异步请求需要有自己的位置上下文。

总结来说，`file->f_pos`代表了文件的持久状态，而`kiocb->ki_pos`代表了特定I/O操作的临时状态。这不是冗余，而是一种精心设计的抽象层次。